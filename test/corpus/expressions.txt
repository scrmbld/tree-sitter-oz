===
procedure definition
===

Increment = proc {$ N Result}
  Result = N + 1
end

---

(source_file
  (block
    (unification
      left: (pattern
        (identifier))
      right: (procedure_definition_expression
        argument: (identifier)
        argument: (identifier)
        body: (in_block
          (block
          (unification
          left: (pattern
            (identifier))
          right: (binary_operator
            left: (identifier)
            right: (int)))))))))

===
function definition
===

Increment = fun {$ N}
  N + 1
end

---

(source_file
  (block
    (unification
      left: (pattern
        (identifier))
      right: (function_definition_expression
        argument: (identifier)
        body: (in_expression
          return: (binary_operator
            left: (identifier)
            right: (int)))))))

===
Binary operators & parenthesis
===

X = (3 + 2) * Y

---

(source_file
  (block
    (unification
      left: (pattern
        (identifier))
      right: (binary_operator
        left: (parenthesis
          (binary_operator
            left: (int)
            right: (int)))
        right: (identifier)))))

===
unary operators
===

X = -1

---

(source_file
  (block
    (unification
      left: (pattern
        (identifier))
      right: (unary_operator
        (int)))))

===
function call
===

X = {Max Y Z}

---

(source_file
  (block
    (unification
      left: (pattern
        (identifier))
      right: (call
        function: (identifier)
        arguments: (argument_list
          argument: (identifier)
          argument: (identifier))))))

===
thread
===

X = thread 1 + 2 end

---

(source_file
  (block
    (unification
      left: (pattern
        (identifier))
      right: (thread_expression
        (in_expression
        return: (binary_operator
          left: (int)
          right: (int)))))))

===
inExpression
===

fun {TestFun W}
  A
  tree(val:X left:L right:R) = T
  fun {FunIncrement X}
    X + 1
  end
  proc {ProcIncrement X ?R}
    R = X + 1
  end
  in
  skip
  A
end

===
tuples
===

X = someLabel(1 (X + 3) {G})

---

(source_file
  (block
    (unification
      left: (pattern
        (identifier))
      right: (tuple
        label: (atom)
        field: (int)
        field: (parenthesis
          (binary_operator
            left: (identifier)
            right: (int)))
        field: (call
          function: (identifier))))))

===
lists
===

X = [1 (X + 3) {G}]

---

(source_file
  (block
    (unification
      left: (pattern
        (identifier))
      right: (list
        (int)
        (parenthesis
          (binary_operator
            left: (identifier)
            right: (int)))
        (call
          function: (identifier))))))

===
case expression -- andthen
===

F = fun {$}
  case Xs
    of (X|Xr) andthen X < 2 then 0
    [] (X|Xr) andthen X > 2 then 3
  end
end

---

(source_file
  (block
    (unification
      left: (pattern
        (identifier))
      right: (function_definition_expression
        body: (in_expression
          return: (case_expression
            target: (identifier)
            pattern: (pattern
              (parenthesis
                (record_construction_op
                  left: (identifier)
                  right: (identifier))))
            condition: (binary_operator
              left: (identifier)
              right: (int))
            consequence: (in_expression
              return: (int))
          alternative: (case_expression_alternate
            pattern: (pattern
              (parenthesis
                (record_construction_op
                  left: (identifier)
                  right: (identifier))))
            condition: (binary_operator
              left: (identifier)
              right: (int))
            consequence: (in_expression
                return: (int)))))))))

===
try_expression
===

fun {SafeDiv X Y}
  try
    if Y == 0 then
      raise divideByZero(X) end
      0
    else
      X div Y
    end
  catch X then
    0
  finally
    skip
  end
end

---
(source_file
  (block
    (function_definition_statement
      name: (identifier)
      argument: (identifier)
      argument: (identifier)
      body: (in_expression
        return: (try_expression
          (in_expression
            return: (if_expression
              condition: (binary_operator
                left: (identifier)
                right: (int))
              consequence: (in_expression
                (raise
                  (in_expression
                    return: (tuple
                      label: (atom)
                      field: (identifier))))
                return: (int))
              alternative: (else_expression_clause
                consequence: (in_expression
                  return: (binary_operator
                    left: (identifier)
                    right: (identifier))))))
          (catch_expression
            pattern: (pattern
              (identifier))
            consequence: (in_expression
                return: (int)))
          (finally
            (in_block
              (block
                (skip)
            ))))))))

