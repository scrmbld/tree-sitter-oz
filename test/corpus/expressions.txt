===
procedure definition
===

Increment = proc {$ N Result}
  Result = N + 1
end

---

(source_file
  (block
    (unification
      left: (identifier)
      right: (procedure_definition_expression
        argument: (identifier)
        argument: (identifier)
        body: (in_block
          (block
          (unification
          left: (identifier)
          right: (binary_operator
            left: (identifier)
            right: (int)))))))))

===
function definition
===

Increment = fun {$ N}
  N + 1
end

---

(source_file
  (block
    (unification
      left: (identifier)
      right: (function_definition_expression
        argument: (identifier)
        body: (in_expression
          return: (binary_operator
            left: (identifier)
            right: (int)))))))

===
Binary operators & parenthesis
===

X = (3 + 2) * Y

---

(source_file
  (block
    (unification
      left: (identifier)
      right: (binary_operator
        left: (parenthesis
          (binary_operator
            left: (int)
            right: (int)))
        right: (identifier)))))

===
unary operators
===

X = -1

---

(source_file
  (block
    (unification
      left: (identifier)
      right: (unary_operator
        (int)))))

===
function call
===

X = {Max Y Z}

---

(source_file
  (block
    (unification
      left: (identifier)
      right: (call
        function: (identifier)
        arguments: (argument_list
          argument: (identifier)
          argument: (identifier))))))

===
thread
===

X = thread 1 + 2 end

---

(source_file
  (block
    (unification
      left: (identifier)
      right: (thread_expression
        (in_expression
        return: (binary_operator
          left: (int)
          right: (int)))))))

===
inExpression
===

fun {TestFun W}
  A
  tree(val:X left:L right:R) = T
  fun {FunIncrement X}
    X + 1
  end
  proc {ProcIncrement X ?R}
    R = X + 1
  end
  in
  skip Basic
  A
end

===
tuples
===

X = someLabel(1 (X + 3) {G})

---

(source_file
  (block
    (unification
      left: (identifier)
      right: (tuple
        label: (atom)
        field: (int)
        field: (parenthesis
          (binary_operator
            left: (identifier)
            right: (int)))
        field: (call
          function: (identifier))))))

===
lists
===

X = [1 (X + 3) {G}]

---

(source_file
  (block
    (unification
      left: (identifier)
      right: (list
        (int)
        (parenthesis
          (binary_operator
            left: (identifier)
            right: (int)))
        (call
          function: (identifier))))))

===
case expression -- andthen
===

F = fun {$}
  case Xs
    of (X|Xr) andthen X < 2 then 0
    [] (X|Xr) andthen X > 2 then 3
  end
end

---

(source_file
  (block
    (unification
      left: (identifier)
      right: (function_definition_expression
        body: (in_expression
          return: (case_expression
            target: (identifier)
            pattern: (pattern
              (parenthesis
                (record_construction_op
                  left: (identifier)
                  right: (identifier))))
            condition: (binary_operator
              left: (identifier)
              right: (int))
            consequence: (in_expression
              return: (int))
          alternative: (case_expression_alternate
            pattern: (pattern
              (parenthesis
                (record_construction_op
                  left: (identifier)
                  right: (identifier))))
            condition: (binary_operator
              left: (identifier)
              right: (int))
            consequence: (in_expression
                return: (int)))))))))
