===
skip statement
===

skip
---

(source_file
  (block
    (skip)))

===
local statement
===

local X (Y|Z) = {G} in
  skip
end

---

(source_file
  (block
    (local_definition
      definitions: (in
        (identifier)
        (unification
          left: (pattern
            (parenthesis
              (record_construction_op
                left: (identifier)
                right: (identifier))))
          right: (call
            function: (identifier))))
      body: (block
        (skip)))))

===
unification
===

X = 1
Z = Y
tree(left:A right:B) = T
(X|Xs) = {G}

---

(source_file
  (block
    (unification
      left: (pattern
        (identifier))
      right: (int))
    (unification
      left: (pattern
        (identifier))
      right: (identifier))
    (unification
      left: (pattern
        (record
          label: (atom)
          field: (record_field
            name: (atom)
            value: (identifier))
          field: (record_field
            name: (atom)
            value: (identifier))))
      right: (identifier))
      (unification
        left: (pattern
          (parenthesis
            (record_construction_op
            left: (identifier)
            right: (identifier))))
        right: (call
          function: (identifier)))))

===
assignment
===

X := Y
Z := 2 + @W

---

(source_file
  (block
    (assignment
      left: (identifier)
      right: (identifier))
    (assignment
      left: (identifier)
      right: (binary_operator
        left: (int)
        right: (unary_operator
          (identifier))))))

===
newCell
===

newCell 0 X
newCell Y Z
newCell (7 + @U) V

---

(source_file
  (block
    (newcell
      (int)
      (identifier))
    (newcell
      (identifier)
      (identifier))
    (newcell
      (parenthesis
        (binary_operator
          left: (int)
          right: (unary_operator
            (identifier))))
      (identifier))))

===
if statement
===

if A then Y=1 in
  skip
elseif B then
  skip
else
  skip
end

---

(source_file
  (block
    (if_statement
      condition: (identifier)
      consequence: (in_block
        definitions: (in
          (unification
            left: (pattern
              (identifier))
            right: (int)))
        (block
          (skip)))
      alternative: (elseif_clause
        condition: (identifier)
        consequence: (in_block
          (block
            (skip))))
      alternative: (else_clause
        consequence: (in_block
          (block
            (skip)))))))

===
case statement
===

case T of tree(left:A right:B) then
  skip
[] false then
  skip
else
  skip
end

---

(source_file
  (block
    (case_statement
      target: (identifier)
      pattern: (pattern
        (record
          label: (atom)
          field: (record_field
            name: (atom)
            value: (identifier))
          field: (record_field
            name: (atom)
            value: (identifier))))
      consequence: (in_block
        (block
          (skip)))
      alternative: (case_alternate
        pattern: (pattern
          (bool))
        consequence: (in_block
          (block
            (skip))))
      alternative: (else_clause
        consequence: (in_block
          (block
            (skip)))))))

===
case statement -- elseless
===

case T of tree(left:A right:B) then
  skip
[] false then
  skip
end

---

(source_file
  (block
    (case_statement
      target: (identifier)
      pattern: (pattern
        (record
          label: (atom)
          field: (record_field
            name: (atom)
            value: (identifier))
          field: (record_field
            name: (atom)
            value: (identifier))))
      consequence: (in_block
        (block
          (skip)))
      alternative: (case_alternate
        pattern: (pattern
          (bool))
        consequence: (in_block
          (block
            (skip)))))))

===
case statement -- andthen
===

case Xs#Ys
  of nil#Ys andthen Ys > 2 then skip
  [] Xs#nil then skip
  [] X|Xr andthen X =< Y then skip
else skip end

---

(source_file
  (block
    (case_statement
      target: (record_construction_op
        left: (identifier)
        right: (identifier))
      pattern: (pattern
        (record_construction_op
          left: (atom)
          right: (identifier)))
      condition: (binary_operator
        left: (identifier)
        right: (int))
      consequence: (in_block
        (block
          (skip)))
      alternative: (case_alternate
        pattern: (pattern
          (record_construction_op
            left: (identifier)
            right: (atom)))
        consequence: (in_block
          (block
            (skip))))
      alternative: (case_alternate
        pattern: (pattern
          (record_construction_op
            left: (identifier)
            right: (identifier)))
        condition: (binary_operator
            left: (identifier)
            right: (identifier))
        consequence: (in_block
          (block
            (skip))))
      alternative: (else_clause
        consequence: (in_block
          (block
            (skip)))))))


===
procedure definition
===

proc {Max X Y Z}
  skip
end

---

(source_file
  (block
    (procedure_definition_statement
      name: (identifier)
      argument: (identifier)
      argument: (identifier)
      argument: (identifier)
      body: (in_block
        (block
          (skip))))))

===
function definition
===

fun {Max X Y} B in
  {Gt X Y B}
  if B then
    X
  else
    Y
  end
end

---

(source_file
  (block
    (function_definition_statement
      name: (identifier)
      argument: (identifier)
      argument: (identifier)
      body: (in_expression
        definitions: (in
          (identifier))
        (call
          function: (identifier)
          arguments: (argument_list
            argument: (identifier)
            argument: (identifier)
            argument: (identifier)))
        return: (if_expression
          condition: (identifier)
          consequence: (in_expression
            return: (identifier))
          alternative: (else_expression_clause
            consequence: (in_expression
              return: (identifier))))))))

===
call statement
===

{IntPlus X 1 Z}
{IntPlus X (Y + 1) Z}
{IntPlus X {Max W Y}  Z}

---
(source_file
  (block
    (call
      function: (identifier)
      arguments: (argument_list
        argument: (identifier)
        argument: (int)
        argument: (identifier)))
    (call
      function: (identifier)
      arguments: (argument_list
        argument: (identifier)
        argument: (parenthesis
            (binary_operator
                left: (identifier)
                right: (int)))
        argument: (identifier)))
    (call
      function: (identifier)
      arguments: (argument_list
        argument: (identifier)
        argument: (call
            function: (identifier)
            arguments: (argument_list
                argument: (identifier)
                argument: (identifier)))
        argument: (identifier)))))

===
thread statement
===

thread
  skip
end

---
(source_file
  (block
    (thread
      body: (in_block
        (block
          (skip))))))

===
inStatement (in_block)
===

if B then
  A
  tree(val:X left:L right:R) = T
  fun {FunIncrement X}
    X + 1
  end
  proc {ProcIncrement X ?R}
    R = X + 1
  end
  in
  skip
end

---
(source_file
  (block
    (if_statement
      condition: (identifier)
      consequence: (in_block
        definitions: (in
          (identifier)
          (unification
            left: (pattern
              (record
                label: (atom)
                field: (record_field
                  name: (atom)
                  value: (identifier))
                field: (record_field
                  name: (atom)
                  value: (identifier))
                field: (record_field
                  name: (atom)
                  value: (identifier))))
            right: (identifier))
            (function_definition_statement
              name: (identifier)
              argument: (identifier)
              body: (in_expression
              return: (binary_operator
                left: (identifier)
                right: (int))))
            (procedure_definition_statement
              name: (identifier)
              argument: (identifier)
              argument: (identifier)
              body: (in_block
              (block
                (unification
                  left: (pattern
                    (identifier))
                  right: (binary_operator
                    left: (identifier)
                    right: (int)))))))
          (block
            (skip))))))

===
lazy
===

Y = fun lazy {$} X end
fun lazy {F} X end
Y = proc lazy {$} skip end
proc lazy {P} skip end

---

(source_file
  (block
    (unification
      left: (pattern
        (identifier))
      right: (function_definition_expression
        body: (in_expression
          return: (identifier))))
    (function_definition_statement
      name: (identifier)
      body: (in_expression
        return: (identifier)))
    (unification
      left: (pattern
        (identifier))
      right: (procedure_definition_expression
        body: (in_block
          (block
            (skip)))))
    (procedure_definition_statement
      name: (identifier)
      body: (in_block
        (block
          (skip))))))


===
raise
===

raise illFormedExpression(E) end

---

(source_file
  (block
    (raise
      (in_expression
        return: (tuple
          label: (atom)
          field: (identifier))))))

===
try -- no alternate catches
===

try
  X = 12 / Y
catch divideByZero(E) then
  skip
end

---
(source_file
  (block
    (try
      (in_block
        (block
          (unification
            left: (pattern
              (identifier))
            right: (binary_operator
              left: (int)
              right: (identifier)))))
    (catch
      pattern: (pattern
        (tuple
          label: (atom)
          field: (identifier)))
      consequence: (in_block
        (block
          (skip)))))))

===
try -- alternate catches and finally
===

try
  X = 12 / Y
catch divideByZero(E) then
  skip
[] illFormedExp(E) then
  skip
finally
  skip
end

---

(source_file
  (block
    (try
      (in_block
        (block
          (unification
            left: (pattern
              (identifier))
            right: (binary_operator
              left: (int)
              right: (identifier)))))
    (catch
      pattern: (pattern
        (tuple
          label: (atom)
          field: (identifier)))
      consequence: (in_block
        (block
          (skip)))
      alternative: (catch_alternate
        pattern: (pattern
          (tuple
            label: (atom)
            field: (identifier)))
        consequence:
          (in_block
            (block
              (skip)))))
    (finally
      (in_block
        (block
          (skip)))))))
