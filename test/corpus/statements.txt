====
skip statement
====

skip Basic
skip Stack
skip Store
skip Full
skip Check

---

(source_file
  (block
    (skip)
    (skip)
    (skip)
    (skip)
    (skip)
  )
)

=====
local statement
=====

local X (Y|Z) = {G} in
  skip Browse X
end

---
(source_file
  (block
    (local_definition
      definitions: (in
        (identifier)
        (assignment
          left: (pattern
            (parenthesis
              (record_construction_op
                left: (identifier)
                right: (identifier))))
          right: (call
            function: (identifier))))
      body: (block
        (skip
          argument: (identifier))))))

===
assignment
===

X = 1
Z = Y
tree(left:A right:B) = T
(X|Xs) = {G}

---

(source_file
  (block
    (assignment
      left: (identifier)
      right: (int))
    (assignment
      left: (identifier)
      right: (identifier))
    (assignment
      left: (pattern
        (record
          label: (atom)
          field: (record_field
            name: (atom)
            value: (identifier))
          field: (record_field
            name: (atom)
            value: (identifier))))
      right: (identifier))
      (assignment
        left: (pattern
          (parenthesis
            (record_construction_op
            left: (identifier)
            right: (identifier))))
        right: (call
          function: (identifier)))))

===
if statement
===

if A then Y=1 in
  skip Browse X
elseif B then
  skip Basic
else
  skip Basic
end

---

(source_file
  (block
    (if_statement
      condition: (identifier)
      consequence: (in_block
        definitions: (in
          (assignment
            left: (identifier)
            right: (int)))
        (block
          (skip
            argument: (identifier))))
      alternative: (elseif_clause
        condition: (identifier)
        consequence: (in_block
          (block
            (skip))))
      alternative: (else_clause
        consequence: (in_block
          (block
            (skip)))))))

===
case statement
===

case T of tree(left:A right:B) then
  skip Browse A
[] false then
  skip Basic
else
  skip Basic
end

---

(source_file
  (block
    (case_statement
      target: (identifier)
      pattern: (pattern
        (record
          label: (atom)
          field: (record_field
            name: (atom)
            value: (identifier))
          field: (record_field
            name: (atom)
            value: (identifier))))
      body: (in_block
        (block
          (skip
            argument: (identifier))))
      alternative: (case_alternate
        pattern: (pattern
          (bool))
        body: (in_block
          (block
            (skip))))
      alternative: (else_clause
        consequence: (in_block
          (block
            (skip)))))))

===
case statement -- elseless
===

case T of tree(left:A right:B) then
  skip Browse A
[] false then
  skip Basic
end

---

(source_file
  (block
    (case_statement
      target: (identifier)
      pattern: (pattern
        (record
          label: (atom)
          field: (record_field
            name: (atom)
            value: (identifier))
          field: (record_field
            name: (atom)
            value: (identifier))))
      body: (in_block
        (block
          (skip
            argument: (identifier))))
      alternative: (case_alternate
        pattern: (pattern
          (bool))
        body: (in_block
          (block
            (skip)))))))

===
case statement -- andthen
===

case Xs#Ys
  of nil#Ys andthen Ys > 2 then skip Basic
  [] Xs#nil then skip Basic
  [] X|Xr andthen X =< Y then skip Basic
else skip Basic end

---

(source_file
  (block
    (case_statement
      target: (record_construction_op
        left: (identifier)
        right: (identifier))
      pattern: (pattern
        (record_construction_op
          left: (atom)
          right: (identifier)))
      condition: (binary_operator
        left: (identifier)
        right: (int))
      body: (in_block
        (block
          (skip)))
      alternative: (case_alternate
        pattern: (pattern
          (record_construction_op
            left: (identifier)
            right: (atom)))
        body: (in_block
          (block
            (skip))))
      alternative: (case_alternate
        pattern: (pattern
          (record_construction_op
            left: (identifier)
            right: (identifier)))
        condition: (binary_operator
            left: (identifier)
            right: (identifier))
        body: (in_block
          (block
            (skip))))
      alternative: (else_clause
        consequence: (in_block
          (block
            (skip)))))))


===
procedure definition
===

proc {Max X Y Z}
  skip Basic
end

---

(source_file
  (block
    (procedure_definition_statement
      name: (identifier)
      argument: (identifier)
      argument: (identifier)
      argument: (identifier)
      body: (in_block
        (block
          (skip))))))

===
function definition
===

fun {Max X Y} B in
  {Gt X Y B}
  if B then
    X
  else
    Y
  end
end

---

(source_file
  (block
    (function_definition_statement
      name: (identifier)
      argument: (identifier)
      argument: (identifier)
      body: (in_expression
        definitions: (in
          (identifier))
        (call
          function: (identifier)
          arguments: (argument_list
            argument: (identifier)
            argument: (identifier)
            argument: (identifier)))
        return: (if_expression
          condition: (identifier)
          consequence: (in_expression
            return: (identifier))
          alternative: (else_expression_clause
            (in_expression
              return: (identifier))))))))

===
call statement
===

{IntPlus X 1 Z}
{IntPlus X (Y + 1) Z}
{IntPlus X {Max W Y}  Z}

---
(source_file
  (block
    (call
      function: (identifier)
      arguments: (argument_list
        argument: (identifier)
        argument: (int)
        argument: (identifier)))
    (call
      function: (identifier)
      arguments: (argument_list
        argument: (identifier)
        argument: (parenthesis
            (binary_operator
                left: (identifier)
                right: (int)))
        argument: (identifier)))
    (call
      function: (identifier)
      arguments: (argument_list
        argument: (identifier)
        argument: (call
            function: (identifier)
            arguments: (argument_list
                argument: (identifier)
                argument: (identifier)))
        argument: (identifier)))))

===
thread statement
===

thread
  skip Basic
end

---
(source_file
  (block
    (thread
      body: (in_block
        (block
          (skip))))))

===
inStatement (in_block)
===

if B then
  A
  tree(val:X left:L right:R) = T
  fun {FunIncrement X}
    X + 1
  end
  proc {ProcIncrement X ?R}
    R = X + 1
  end
  in
  skip Basic
end

---
(source_file
  (block
    (if_statement
      condition: (identifier)
      consequence: (in_block
        definitions: (in
          (identifier)
          (assignment
            left: (pattern
              (record
                label: (atom)
                field: (record_field
                  name: (atom)
                  value: (identifier))
                field: (record_field
                  name: (atom)
                  value: (identifier))
                field: (record_field
                  name: (atom)
                  value: (identifier))))
            right: (identifier))
            (function_definition_statement
              name: (identifier)
              argument: (identifier)
              body: (in_expression
              return: (binary_operator
                left: (identifier)
                right: (int))))
            (procedure_definition_statement
              name: (identifier)
              argument: (identifier)
              argument: (identifier)
              body: (in_block
              (block
                (assignment
                  left: (identifier)
                  right: (binary_operator
                    left: (identifier)
                    right: (int)))))))
          (block
            (skip))))))

===
byNeed
===

byNeed fun {$} X end Y
byNeed proc {$ R} R = X end Y

---

(source_file
  (block
    (by_need
      function: (function_definition_expression
        body: (in_expression
          return: (identifier)))
      target: (identifier))
    (by_need
      function: (procedure_definition_expression
        argument: (identifier)
        body: (in_block
          (block
            (assignment
              left: (identifier)
              right: (identifier)))))
      target: (identifier))))
